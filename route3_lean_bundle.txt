================================================================================
ROUTE 3 LEAN FILES BUNDLE
Generated: $(date)
================================================================================

This file contains all Lean 4 files from the Route 3 (Explicit Formula / Weil-Li)
proof attempt for the Riemann Hypothesis.

Files are sourced from:
- Main workspace: RiemannRecognitionGeometry/ExplicitFormula/
- Worktree (prioritized for duplicates): worktree copy of RiemannRecognitionGeometry/ExplicitFormula/

================================================================================

================================================================================
FILE: Defs.lean (TestSpace typeclass)
================================================================================

/-
# Route 3 (major rebuild): explicit-formula infrastructure

This folder intentionally does **not** import any of the existing
Carleson/BMO/Whitney Recognition-Geometry infrastructure.

It provides a mechanically-checkable skeleton for the Lagarias/Weil/Li
explicit-formula route.
-/

import Mathlib.Data.Complex.Basic

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

universe u

/--
An abstract test-function space in the sense of Lagarias' Mellin-transform
normalization.

We keep this abstract on purpose: the Route 3 skeleton is about wiring the
logical implications correctly, while isolating analytic convergence issues
as explicit assumptions.
-/
class TestSpace (F : Type u) where
  /-- Mellin transform `M[f](s)`. -/
  Mellin : F â†’ â„‚ â†’ â„‚
  /-- Multiplicative convolution `f * g`. -/
  conv : F â†’ F â†’ F
  /-- Involution `\widetilde f(x) = x^{-1} f(x^{-1})`. -/
  tilde : F â†’ F
  /-- Complex conjugation on the test side (used in `\widetilde{\overline f}`). -/
  star : F â†’ F
  /-- Mellin turns convolution into multiplication. -/
  mellin_conv : âˆ€ (f g : F) (s : â„‚),
    Mellin (conv f g) s = Mellin f s * Mellin g s
  /-- Mellin intertwines the involution by `s â†¦ 1 - s`. -/
  mellin_tilde : âˆ€ (f : F) (s : â„‚),
    Mellin (tilde f) s = Mellin f (1 - s)

attribute [simp] TestSpace.mellin_conv TestSpace.mellin_tilde

namespace TestSpace

variable {F : Type u} [TestSpace F]

notation "M[" f "](" s ")" => TestSpace.Mellin f s
infixl:70 " â‹†â‚˜ " => TestSpace.conv
notation "Ëœâ‚˜" f => TestSpace.tilde f
notation "â‹†â‚œ" f => TestSpace.star f

/-- The quadratic-form test `f * \widetilde{\overline f}` (abstractly). -/
def quad (f : F) : F := f â‹†â‚˜ Ëœâ‚˜ (â‹†â‚œ f)

end TestSpace

end ExplicitFormula
end RiemannRecognitionGeometry



================================================================================
FILE: Lagarias.lean (Framework & Weil positivity)
================================================================================

/-
# Lagarias (2007): explicit formula and Weil positivity (Route 3 skeleton)

This file encodes the *statements* (as Lean-typed axioms/structures) of:
- Lagarias Thm 3.1 (Guinandâ€“Weil explicit formula), and
- Lagarias Thm 3.2 (Weil positivity criterion for RH),

in the Mellin-transform normalization used in `renormalized_tail_bound.md` Â§8.

No Carleson/BMO/Whitney infrastructure is imported here.
-/

import Mathlib.NumberTheory.LSeries.RiemannZeta
import RiemannRecognitionGeometry.ExplicitFormula.Defs

noncomputable section

open Complex

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open TestSpace

/-- Lagarias' completed zeta in the normalization
`Î¾(s) = (1/2) s (s-1) Ï€^{-s/2} Î“(s/2) Î¶(s)`.

We define it using Mathlib's `completedRiemannZeta`:
`completedRiemannZeta s = Ï€^{-s/2} Î“(s/2) Î¶(s)` (up to harmless point-value conventions
at `s=0,1`). The prefactor `s(s-1)` removes the poles and yields an entire function.
-/
def xiLagarias (s : â„‚) : â„‚ := (1/2 : â„‚) * s * (s - 1) * completedRiemannZeta s

lemma xiLagarias_one_sub (s : â„‚) : xiLagarias (1 - s) = xiLagarias s := by
  unfold xiLagarias
  -- First apply the functional equation to the completed zeta factor.
  rw [completedRiemannZeta_one_sub s]
  -- The remaining equality is just commutative-ring algebra in `s`.
  ring_nf

/-!
## Zeros: relating `xiLagarias` and `riemannZeta` (basic correspondence lemmas)

These lemmas are not the Route 3 bottleneck; they are routine â€œinterface glueâ€
needed to connect Lagarias-style statements (formulated in terms of `Î¾`) with
Mathlib's `RiemannHypothesis` predicate (formulated in terms of `Î¶`).

We keep hypotheses explicit to avoid sweeping analytic subtleties under the rug.
-/

lemma completedRiemannZeta_eq_zero_of_riemannZeta_eq_zero {s : â„‚}
    (hs0 : s â‰  0) (hsre : 0 < s.re) (hz : riemannZeta s = 0) :
    completedRiemannZeta s = 0 := by
  have hÎ“ : Complex.Gammaâ„ s â‰  0 :=
    Complex.Gammaâ„_ne_zero_of_re_pos hsre
  have hdef := riemannZeta_def_of_ne_zero (s := s) hs0
  have hdiv : completedRiemannZeta s / Complex.Gammaâ„ s = 0 := by
    simpa [hdef] using hz
  rcases (div_eq_zero_iff).1 hdiv with hcomp | hÎ“0
  Â· exact hcomp
  Â· exact False.elim (hÎ“ hÎ“0)

lemma xiLagarias_eq_zero_of_riemannZeta_eq_zero {s : â„‚}
    (hs0 : s â‰  0) (hsre : 0 < s.re) (hz : riemannZeta s = 0) :
    xiLagarias s = 0 := by
  have hcomp : completedRiemannZeta s = 0 :=
    completedRiemannZeta_eq_zero_of_riemannZeta_eq_zero (s := s) hs0 hsre hz
  unfold xiLagarias
  simp [hcomp]

lemma riemannZeta_eq_zero_of_xiLagarias_eq_zero {s : â„‚}
    (hs0 : s â‰  0) (hs1 : s â‰  1) (hsre : 0 < s.re) (hxi : xiLagarias s = 0) :
    riemannZeta s = 0 := by
  have hÎ“ : Complex.Gammaâ„ s â‰  0 :=
    Complex.Gammaâ„_ne_zero_of_re_pos hsre
  have hdef := riemannZeta_def_of_ne_zero (s := s) hs0
  have hpref : ((1/2 : â„‚) * s * (s - 1)) â‰  0 := by
    have hhalf : (1/2 : â„‚) â‰  0 := by norm_num
    have hsMinus1 : s - 1 â‰  0 := by
      intro h
      apply hs1
      exact sub_eq_zero.mp h
    have h1 : (1/2 : â„‚) * s â‰  0 := mul_ne_zero hhalf hs0
    have h2 : ((1/2 : â„‚) * s) * (s - 1) â‰  0 := mul_ne_zero h1 hsMinus1
    simpa [mul_assoc] using h2
  -- Extract `completedRiemannZeta s = 0` from `xiLagarias s = 0`.
  have hcomp : completedRiemannZeta s = 0 := by
    unfold xiLagarias at hxi
    -- reassociate to isolate the `completedRiemannZeta` factor
    have hxi' : ((1/2 : â„‚) * s * (s - 1)) * completedRiemannZeta s = 0 := by
      simpa [mul_assoc, mul_left_comm, mul_comm] using hxi
    rcases mul_eq_zero.mp hxi' with hpre0 | hcomp0
    Â· exact False.elim (hpref hpre0)
    Â· exact hcomp0
  -- Now use `Î¶ = Î› / Î“` (Mathlib's interface) and the nonvanishing of `Î“`.
  rw [hdef]
  simp [hcomp, hÎ“]

/--
A packaged set of explicit-formula functionals in Lagarias' Mellin normalization.

`W0(f) = M[f](0)`, `W2(f) = M[f](1)`, and `W1(f) = âˆ‘_Ï M[f](Ï)` (symmetric summation).
We keep `W1` and `Warith` abstract, since their analytic definition/convergence
is part of the Route 3 bottleneck.
-/
structure LagariasFramework (F : Type) [TestSpace F] where
  /-- The spectral zero-sum functional `W^{(1)}(f) = âˆ‘_Ï M[f](Ï)` (symmetric summation). -/
  W1 : F â†’ â„‚
  /-- The arithmetic-side functional `W_arith(f) = W_âˆ(f) + âˆ‘_p W_p(f)`. -/
  Warith : F â†’ â„‚

  /-- Lagarias Thm 3.1 (Explicit Formula): `W_spec(f) = W_arith(f)` for all nice `f`. -/
  explicitFormula : âˆ€ f : F, M[f](1) - W1 f + M[f](0) = Warith f

  /-- Lagarias Thm 3.2 (Weil positivity): `RH â†” (âˆ€f, Re(W1(f*~\bar f)) â‰¥ 0)`. -/
  weilPositivity :
      RiemannHypothesis â†” (âˆ€ f : F, 0 â‰¤ (W1 (TestSpace.quad (F:=F) f)).re)

/-- `W^{(2)}(f) = M[f](1)` (spectral boundary term). -/
def W2 {F : Type} [TestSpace F] (f : F) : â„‚ := M[f](1)

/-- `W^{(0)}(f) = M[f](0)` (spectral boundary term). -/
def W0 {F : Type} [TestSpace F] (f : F) : â„‚ := M[f](0)

/-- `W_spec(f) = W2(f) - W1(f) + W0(f)` (Lagarias). -/
def Wspec {F : Type} [TestSpace F] (f : F) (L : LagariasFramework F) : â„‚ :=
  W2 f - L.W1 f + W0 f

-- Convenience projection: view `Wspec` as a function once `L` is fixed.
namespace LagariasFramework

variable {F : Type} [TestSpace F] (L : LagariasFramework F)

/-- `W_spec` as a unary functional for a fixed framework. -/
def Wspec (f : F) : â„‚ :=
  (W2 f) - (L.W1 f) + (W0 f)

/-- `WeilGate`: the explicit-formula positivity hypothesis (the Route 3 bottleneck). -/
def WeilGate : Prop := âˆ€ f : F, 0 â‰¤ (L.W1 (TestSpace.quad (F:=F) f)).re

end LagariasFramework

-- Provide the `Wspec` used in the structure field above.
-- (We keep it outside the structure to avoid dependent recursion issues.)
@[simp] lemma Wspec_eq (F : Type) [TestSpace F] (L : LagariasFramework F) (f : F) :
    (LagariasFramework.Wspec (F:=F) L f) = W2 f - L.W1 f + W0 f := rfl

end ExplicitFormula
end RiemannRecognitionGeometry



================================================================================
FILE: Li.lean (Li criterion)
================================================================================

/-
# Li coefficients and Li criterion (Route 3 skeleton)

This file records (as Lean-typed statements) the Li-criterion gate for RH and
its relationship to the explicit-formula/Weil gate.

Analytic convergence and the â€œsum over zerosâ€ identity are intentionally
packaged as assumptions.
-/

import Mathlib.NumberTheory.LSeries.RiemannZeta
import Mathlib.Analysis.Complex.Basic
import RiemannRecognitionGeometry.ExplicitFormula.Lagarias

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open TestSpace
open ComplexConjugate

/--
A Li-criterion package (Li 1997; Lagarias 2007, Thm 6.5), layered on top of a
Lagarias explicit-formula framework.

We take Li coefficients `Î» n` as real numbers (as in the criterion), and record
`RH â†” (âˆ€nâ‰¥1, Î» n â‰¥ 0)`.

Further identities (sum over zeros, and the Bombieriâ€“Lagarias realization as a
Weil functional) are represented as explicit fields, but kept abstract.
-/
structure LiFramework (F : Type) [TestSpace F] extends LagariasFramework F where
  /-- Li coefficients `Î»â‚™` (real). -/
  lambda : â„• â†’ â„

  /-- Li criterion (Lagarias 2007, Thm 6.5): `RH â†” âˆ€ nâ‰¥1, Î»â‚™ â‰¥ 0`. -/
  liCriterion : RiemannHypothesis â†” (âˆ€ n : â„•, 1 â‰¤ n â†’ 0 â‰¤ lambda n)

  /-- Optional: record the (symmetric) sum-over-zeros formula as a named assumption. -/
  sumOverZerosFormula : Prop

  /-- Optional: record the Bombieriâ€“Lagarias/Lagarias realization `Î»â‚™ = WÂ¹(Ï†â‚™ * \widetilde{\bar Ï†â‚™})`.
      This typically requires extending the test-function class beyond compact support. -/
  lambdaAsWeil : Prop

/-!
## The local RH â†’ termwise nonnegativity step (Li)

The (symmetric) sum-over-zeros formula for Li coefficients is

`Î»â‚™ = âˆ‘_Ï (1 - (1 - 1/Ï)^n)`,

with a specific convergence convention (Lagarias Â§6.3). Under **RH**, each nontrivial zero `Ï`
satisfies `Ï.re = 1/2`, and then the factor `z := 1 - 1/Ï` lies on the unit circle (`abs z = 1`).
Consequently,

`Re(1 - z^n) = 1 - Re(z^n) â‰¥ 0`.

The lemmas below formalize exactly this *local* inequality. Upgrading it to
`RH â†’ (âˆ€nâ‰¥1, Î»â‚™ â‰¥ 0)` requires (and is essentially equivalent to) the analytic
sum-over-zeros identity plus the justification for exchanging `Re` with the symmetric sum.
-/

namespace LiAux

/-- The basic Li summand `1 - (1 - 1/Ï)^n`. -/
def liTerm (n : â„•) (Ï : â„‚) : â„‚ :=
  (1 : â„‚) - (1 - 1 / Ï) ^ n

lemma normSq_sub_one_eq_normSq_of_re_eq_half {Ï : â„‚} (hÏ : Ï.re = (1 / 2 : â„)) :
    Complex.normSq (Ï - 1) = Complex.normSq Ï := by
  simp [Complex.normSq_apply, hÏ]
  ring

lemma abs_one_sub_inv_eq_one {Ï : â„‚} (hÏ : Ï.re = (1 / 2 : â„)) (hÏ0 : Ï â‰  0) :
    Complex.abs (1 - 1 / Ï) = 1 := by
  have hrew : (1 - Ïâ»Â¹) = (Ï - 1) * Ïâ»Â¹ := by
    simp [sub_eq_add_neg, mul_add, add_mul, mul_assoc, hÏ0]
  have hns : Complex.normSq Ï â‰  0 := by
    intro h0
    have : Ï = 0 := (Complex.normSq_eq_zero).1 h0
    exact hÏ0 this
  have hn : Complex.normSq (1 - Ïâ»Â¹) = 1 := by
    calc
      Complex.normSq (1 - Ïâ»Â¹)
          = Complex.normSq ((Ï - 1) * Ïâ»Â¹) := by simp [hrew]
      _ = Complex.normSq (Ï - 1) * Complex.normSq (Ïâ»Â¹) := by
            simpa using (Complex.normSq.map_mul (Ï - 1) Ïâ»Â¹)
      _ = Complex.normSq (Ï - 1) * (Complex.normSq Ï)â»Â¹ := by
            simpa using (map_invâ‚€ (f := Complex.normSq) Ï)
      _ = Complex.normSq Ï * (Complex.normSq Ï)â»Â¹ := by
            simp [normSq_sub_one_eq_normSq_of_re_eq_half (Ï := Ï) hÏ]
      _ = 1 := by
            simpa [hns] using (mul_inv_cancelâ‚€ (Complex.normSq Ï))
  simpa [div_eq_mul_inv, Complex.abs_def, hn]

lemma re_one_sub_pow_nonneg_of_abs_eq_one (z : â„‚) (n : â„•) (hz : Complex.abs z = 1) :
    0 â‰¤ ((1 : â„‚) - z ^ n).re := by
  have h1 : ((1 : â„‚) - z ^ n).re = (1 : â„) - (z ^ n).re := by simp
  have hre : (z ^ n).re â‰¤ Complex.abs (z ^ n) := Complex.re_le_abs _
  have habs : Complex.abs (z ^ n) = 1 := by
    simpa [hz] using (map_pow Complex.abs z n)
  have hre1 : (z ^ n).re â‰¤ (1 : â„) := by simpa [habs] using hre
  have : 0 â‰¤ (1 : â„) - (z ^ n).re := sub_nonneg.mpr hre1
  simpa [h1] using this

lemma liTerm_re_nonneg_of_re_eq_half {Ï : â„‚} (n : â„•)
    (hÏ : Ï.re = (1 / 2 : â„)) (hÏ0 : Ï â‰  0) :
    0 â‰¤ (liTerm n Ï).re := by
  have hz : Complex.abs (1 - 1 / Ï) = 1 := abs_one_sub_inv_eq_one (Ï := Ï) hÏ hÏ0
  simpa [liTerm] using (re_one_sub_pow_nonneg_of_abs_eq_one (z := (1 - 1 / Ï)) n hz)

end LiAux

namespace LiFramework

variable {F : Type} [TestSpace F] (L : LiFramework F)

/-- `LiGate`: the countable positivity hypothesis `âˆ€ nâ‰¥1, Î»â‚™ â‰¥ 0`. -/
def LiGate : Prop := âˆ€ n : â„•, 1 â‰¤ n â†’ 0 â‰¤ L.lambda n

end LiFramework

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: MainRoute3.lean (Gate theorems & ReflectionPositivityRealization)
================================================================================

/-
# Route 3 main file: explicit-formula gates â†’ RH

This file exposes the Route 3 â€œgateâ€ theorems:

- `WeilGate â†’ RiemannHypothesis`
- `LiGate â†’ RiemannHypothesis`

All analytic number theory content is isolated behind the Lagarias/Li framework
assumptions; this is a mechanically checkable proof *skeleton*.

Important non-goal (Conreyâ€“Li): we do **not** target de Branges shift-positivity
(pointwise kernel-shift inequalities), which are known to fail for Î¶.
The positivity target here is Weil/Li *averaged* positivity.
-/

import RiemannRecognitionGeometry.ExplicitFormula.Lagarias
import RiemannRecognitionGeometry.ExplicitFormula.Li
import Mathlib.Analysis.InnerProductSpace.Basic

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open TestSpace
open scoped InnerProductSpace

namespace LagariasFramework

variable {F : Type} [TestSpace F] (L : LagariasFramework F)

/-- Route 3 Weil gate: assuming the Weil positivity hypothesis yields RH. -/
theorem WeilGate_implies_RH : L.WeilGate â†’ RiemannHypothesis := by
  intro hGate
  exact (L.weilPositivity).2 hGate

/-- Under RH, Weil positivity holds (the easy direction of Lagarias Thm 3.2). -/
theorem RH_implies_WeilGate : RiemannHypothesis â†’ L.WeilGate := by
  intro hRH
  exact (L.weilPositivity).1 hRH

/-!
## Weil criterion (converse direction) as an explicit Lean proof plan

Lagarias Thm 3.2 asserts `RiemannHypothesis â†” WeilGate`. In the mechanical Route 3 skeleton we
*package* that equivalence as the field `LagariasFramework.weilPositivity`.

For the **unconditional attempt**, it is useful to isolate the exact analytic sub-lemma needed for
the hard direction `WeilGate â†’ RiemannHypothesis`:

> If there exists a nontrivial zero off the critical line, one can construct a test function `f`
> such that the explicit-formula quadratic form `Re(WÂ¹(f â‹† ~\bar f))` is strictly negative.

The structure below records this "off-line zero detector" as a single hypothesis; the resulting
Lean theorem then derives `WeilGate â†’ RiemannHypothesis` without assuming the full equivalence.
-/

/-- A single analytic lemma that would prove the hard direction `WeilGate â†’ RH`. -/
structure WeilConverseDetector where
  /--
  **Detector lemma** (contrapositive of Weil criterion):

  If `Î¶(s)=0` is a nontrivial zero off the critical line, there exists a test function `f`
  with strictly negative quadratic form value `Re(WÂ¹(f â‹† ~\bar f))`.
  -/
  detect_offline_zero :
    âˆ€ s : â„‚,
      riemannZeta s = 0 â†’
      (Â¬ âˆƒ n : â„•, s = -2 * (n + 1)) â†’  -- exclude trivial zeros
      s â‰  1 â†’                       -- exclude the pole
      s.re â‰  (1 / 2 : â„) â†’          -- off the critical line
      âˆƒ f : F, (L.W1 (TestSpace.quad (F := F) f)).re < 0

/--
`WeilGate â†’ RiemannHypothesis`, assuming only the "off-line zero detector" lemma `D`.

This is the exact proof plan for Lagarias Thm 3.2 (hard direction) inside Route 3.
-/
theorem WeilGate_implies_RH_of_detector (D : WeilConverseDetector (L := L)) :
    L.WeilGate â†’ RiemannHypothesis := by
  intro hGate
  intro s hs0 htriv hs1
  by_contra hsRe
  rcases D.detect_offline_zero (s := s) hs0 htriv hs1 hsRe with âŸ¨f, hfnegâŸ©
  have hpos : 0 â‰¤ (L.W1 (TestSpace.quad (F := F) f)).re := hGate f
  exact (not_lt_of_ge hpos) hfneg

end LagariasFramework

namespace LiFramework

variable {F : Type} [TestSpace F] (L : LiFramework F)

/-- Route 3 Li gate: assuming Li-positivity yields RH. -/
theorem LiGate_implies_RH : L.LiGate â†’ RiemannHypothesis := by
  intro hGate
  exact (L.liCriterion).2 hGate

/-- Under RH, Li positivity holds (the easy direction of Li's criterion). -/
theorem RH_implies_LiGate : RiemannHypothesis â†’ L.LiGate := by
  intro hRH
  exact (L.liCriterion).1 hRH

/-!
## Li criterion as an explicit Lean proof plan (converse direction)

As with Weil, the mechanical Route 3 skeleton packages Li's criterion as the field
`LiFramework.liCriterion : RH â†” LiGate`.

For the **unconditional attempt**, we isolate the exact analytic content needed for the hard
direction `(âˆ€ nâ‰¥1, Î»â‚™ â‰¥ 0) â†’ RH`:

> If there exists a nontrivial zero off the critical line, then *some* Li coefficient `Î»â‚™` is
> strictly negative.

The structure below records this contrapositive as a single hypothesis; the resulting theorem then
derives `LiGate â†’ RiemannHypothesis` without assuming the full equivalence.
-/

/-- A single analytic lemma that would prove the hard direction `LiGate â†’ RH`. -/
structure LiConverseDetector where
  /--
  **Detector lemma** (contrapositive of Li's criterion):

  If `Î¶(s)=0` is a nontrivial zero off the critical line, then there exists `n â‰¥ 1` with `Î»â‚™ < 0`.
  -/
  detect_offline_zero :
    âˆ€ s : â„‚,
      riemannZeta s = 0 â†’
      (Â¬ âˆƒ n : â„•, s = -2 * (n + 1)) â†’  -- exclude trivial zeros
      s â‰  1 â†’                       -- exclude the pole
      s.re â‰  (1 / 2 : â„) â†’          -- off the critical line
      âˆƒ n : â„•, 1 â‰¤ n âˆ§ L.lambda n < 0

/--
`LiGate â†’ RiemannHypothesis`, assuming only the "off-line zero detector" lemma `D`.

This is the exact proof plan for the hard direction of Li's criterion inside Route 3.
-/
theorem LiGate_implies_RH_of_detector (D : LiConverseDetector (L := L)) :
    L.LiGate â†’ RiemannHypothesis := by
  intro hGate
  intro s hs0 htriv hs1
  by_contra hsRe
  rcases D.detect_offline_zero (s := s) hs0 htriv hs1 hsRe with âŸ¨n, hn1, hnnegâŸ©
  have hpos : 0 â‰¤ L.lambda n := hGate n hn1
  exact (not_lt_of_ge hpos) hnneg

end LiFramework

/-
## Optional intermediate targets (â€œattackabilityâ€)

These are **not** needed for the mechanical Route 3 skeleton. They simply record,
in Lean-typed form, two intermediate subtargets mentioned in
`renormalized_tail_bound.md` Â§8.8.
-/

namespace OptionalTargets

section DenseReduction

variable {F : Type} [TestSpace F] [TopologicalSpace F]
variable (L : LagariasFramework F)

/-- Target: reduce Weil positivity to a dense subclass, using continuity of the quadratic form. -/
def DenseSubclassReduction : Prop :=
  âˆƒ (S : Set F),
    Dense S âˆ§
    Continuous (fun f : F => (L.W1 (TestSpace.quad (F:=F) f)).re) âˆ§
      ((âˆ€ f : F, f âˆˆ S â†’ 0 â‰¤ (L.W1 (TestSpace.quad (F:=F) f)).re) â†’
        (âˆ€ f : F, 0 â‰¤ (L.W1 (TestSpace.quad (F:=F) f)).re))

end DenseReduction

section LiEventualPositivity

variable {F : Type} [TestSpace F]
variable (L : LiFramework F)

/-- Target: a quantitative lower bound implying eventual Li positivity (hence a finite reduction). -/
def LiEventualPositivityTarget : Prop :=
  âˆƒ (N0 : â„•) (c C Î¸ : â„),
    Î¸ < 1 âˆ§
    (âˆ€ n : â„•, N0 â‰¤ n â†’
      L.lambda n â‰¥ ((n : â„) / 2) * Real.log (n : â„) + c * (n : â„) - C * (n : â„) ^ Î¸)

end LiEventualPositivity

section ReflectionPositivity

variable {F : Type} [TestSpace F] [AddCommGroup F] [Module â„‚ F]
variable (L : LagariasFramework F)

/--
Target: a Hilbert-space realization of the Weil form (reflection positivity / â€œsum over zeros is a
norm-squareâ€).

This is the clean classical-math version of the heuristic â€œthe explicit-formula quadratic form is a
physical cost (hence nonnegative)â€: exhibit a complex Hilbert space `H` and a linear map `T : F â†’ H`
such that the sesquilinear form

`(f,g) â†¦ WÂ¹(f â‹†â‚˜ Ëœâ‚˜(â‹†â‚œ g))`

is literally the inner product `âŸªT f, T gâŸ«`.

Once such a representation exists, Weil positivity `Re(WÂ¹(f â‹†â‚˜ Ëœâ‚˜(â‹†â‚œ f))) â‰¥ 0` is immediate.

Mathematically, proving existence of such a representation is equivalent to proving that the kernel
defined by the explicit formula is positive definite (a GNS/Bochnerâ€“Schwartz style statement). -/
def ReflectionPositivityRealization : Prop :=
  âˆƒ (H : Type) (_ : NormedAddCommGroup H) (_ : InnerProductSpace â„‚ H) (_ : CompleteSpace H)
    (T : F â†’â‚—[â„‚] H),
      âˆ€ f g : F, L.W1 (f â‹†â‚˜ Ëœâ‚˜ (â‹†â‚œ g)) = âŸªT f, T gâŸ«_â„‚

/-- A reflection-positivity realization implies the Route 3 Weil gate `WeilGate`. -/
theorem WeilGate_of_reflectionPositivityRealization
    (h : ReflectionPositivityRealization (L := L)) : L.WeilGate := by
  rcases h with âŸ¨H, _instNACG, _instIP, _instComplete, T, hWâŸ©
  classical
  -- register the existentially-provided structures as instances
  letI : NormedAddCommGroup H := _instNACG
  letI : InnerProductSpace â„‚ H := _instIP
  letI : CompleteSpace H := _instComplete
  intro f
  have hEq : L.W1 (TestSpace.quad (F := F) f) = âŸªT f, T fâŸ«_â„‚ := by
    simpa [TestSpace.quad] using (hW f f)
  have hpos : 0 â‰¤ (âŸªT f, T fâŸ«_â„‚).re := by
    -- use the â„‚-specialization explicitly to avoid typeclass metavariables
    simpa using (inner_self_nonneg (ğ•œ := â„‚) (x := T f))
  simpa [hEq] using hpos

end ReflectionPositivity

end OptionalTargets

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: MathlibBridge.lean (Mathlib Mellin integration)
================================================================================

/-
# Route 3: Mathlib integration (Mellin transform)

This file connects the abstract Route 3 `TestSpace` interface to Mathlib's
actual `mellin` definition (`Mathlib.Analysis.MellinTransform`).

Convention check:
- Route 3 (Lagarias): M[f](s) = âˆ«â‚€^âˆ f(x) x^s dx/x
- Mathlib: mellin f s = âˆ« (t : â„) in Ioi 0, t^(s-1) â€¢ f t

These are equivalent: t^(s-1) dt = t^s (dt/t) = x^s (dx/x).
-/

import Mathlib.Analysis.MellinTransform
import Mathlib.Analysis.SpecialFunctions.Pow.Complex
import Mathlib.MeasureTheory.Integral.SetIntegral
import Mathlib.Analysis.Complex.Basic
import RiemannRecognitionGeometry.ExplicitFormula.Defs

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open MeasureTheory Set Filter Asymptotics TopologicalSpace
open ComplexConjugate

/--
The concrete Mellin transform on functions `f : â„ â†’ â„‚`, using Mathlib's definition.
This matches Lagarias' normalization M[f](s) = âˆ«â‚€^âˆ f(x) x^s dx/x.
-/
def concreteMellin (f : â„ â†’ â„‚) (s : â„‚) : â„‚ :=
  mellin f s

/--
Verifies that `concreteMellin` is chemically compatible with `TestSpace.Mellin`.
(This doesn't prove the `TestSpace` axioms yet, just defines the operation).
-/
lemma concreteMellin_eq_mathlib_mellin (f : â„ â†’ â„‚) (s : â„‚) :
    concreteMellin f s = mellin f s := rfl

/-!
## The Lagarias involution on `(0,âˆ)` and its Mellin intertwining

Lagarias' involution on test functions is:
`~f(x) = (1/x) f(1/x)`.

In Mathlib's Mellin normalization, the key identity is
`mellin (~f) s = mellin f (1 - s)`.

This is a change-of-variables statement and follows from two generic Mellin lemmas:
- `mellin_cpow_smul` (multiplying by `t^a` shifts the Mellin variable by `a`), and
- `mellin_comp_inv` (inverting the input sends `s â†¦ -s`).
-/

/-- Lagarias' involution on functions `f : â„ â†’ â„‚` (values on `t â‰¤ 0` are irrelevant). -/
def tildeFun (f : â„ â†’ â„‚) : â„ â†’ â„‚ :=
  fun t => ((t : â„‚) ^ (-1 : â„‚)) â€¢ f tâ»Â¹

lemma mellin_tildeFun (f : â„ â†’ â„‚) (s : â„‚) :
    mellin (tildeFun f) s = mellin f (1 - s) := by
  -- Expand `tildeFun` and use the generic Mellin shift and inversion lemmas.
  unfold tildeFun
  -- First: pull out the `t^(-1)` factor, shifting `s` by `-1`.
  have h1 :
      mellin (fun t : â„ => ((t : â„‚) ^ (-1 : â„‚)) â€¢ f tâ»Â¹) s =
        mellin (fun u : â„ => f uâ»Â¹) (s - 1) := by
    -- `mellin_cpow_smul` shifts `s` by the exponent `a`.
    simpa [sub_eq_add_neg] using
      (mellin_cpow_smul (f := fun u : â„ => f uâ»Â¹) (s := s) (a := (-1 : â„‚)))
  -- Second: invert the input, sending `(s-1) â†¦ -(s-1) = 1-s`.
  have h2 : mellin (fun u : â„ => f uâ»Â¹) (s - 1) = mellin f (1 - s) := by
    -- `mellin_comp_inv f (s-1)` gives `= mellin f (-(s-1)) = mellin f (1-s)`.
    simpa [sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using
      (mellin_comp_inv (f := f) (s := s - 1))
  exact h1.trans h2

/-!
## Conjugation (`star`) and the Mellin transform

For the RH â†’ Weil-positivity direction we need the standard identity (for convergent Mellin
integrals)

`mellin (starFun f) (star s) = star (mellin f s)`.

This is a Bochner-integral fact: complex conjugation is an â„-linear continuous linear map, hence
commutes with integration, and it commutes with `t â†¦ (t : â„‚) ^ (s - 1)` for `t > 0`.
-/

/-- Pointwise complex conjugation (`star`) on functions `â„ â†’ â„‚`. -/
def starFun (f : â„ â†’ â„‚) : â„ â†’ â„‚ :=
  fun t => star (f t)

/-- For `t > 0`, conjugation commutes with `((t:â„‚)^(s-1))` in the exponent. -/
lemma star_ofReal_cpow {t : â„} (ht : t âˆˆ Ioi (0 : â„)) (s : â„‚) :
    star ((t : â„‚) ^ (s - 1)) = (t : â„‚) ^ (star s - 1) := by
  have ht0 : (0 : â„) â‰¤ t := le_of_lt ht
  have harg : ((t : â„‚).arg) = 0 := Complex.arg_ofReal_of_nonneg ht0
  have hx : (t : â„‚).arg â‰  Real.pi := by
    -- arg is 0, and `Real.pi â‰  0`.
    simpa [harg] using (Real.pi_ne_zero.symm)
  -- Start from `Complex.conj_cpow`, simplify `conj (t:â„‚) = (t:â„‚)`, then conjugate both sides.
  have h := Complex.conj_cpow (x := (t : â„‚)) (n := (s - 1)) hx
  have h' : (t : â„‚) ^ (s - 1) = conj ((t : â„‚) ^ (conj (s - 1))) := by
    simpa [Complex.conj_ofReal] using h
  have : conj ((t : â„‚) ^ (s - 1)) = (t : â„‚) ^ (conj (s - 1)) := by
    simpa using congrArg conj h'
  -- Rewrite `conj` as `star`.
  simpa [map_sub, map_one] using this

/--
If the Mellin transform of `f` converges at `s`, then conjugation commutes with the Mellin
transform at `s`.
-/
lemma mellin_starFun (f : â„ â†’ â„‚) (s : â„‚) (hf : MellinConvergent f s) :
    mellin (starFun f) (star s) = star (mellin f s) := by
  -- Unfold `mellin` as an integral on `Ioi 0`.
  unfold mellin
  -- Use `ContinuousLinearMap.integral_comp_comm` for the â„-linear map `conj`.
  have hÏ† :
      Integrable (fun t : â„ => (t : â„‚) ^ (s - 1) â€¢ f t) (volume.restrict (Ioi (0 : â„))) := by
    simpa [MellinConvergent, IntegrableOn] using hf
  have hconj :
      (âˆ« t : â„, conj ((t : â„‚) ^ (s - 1) â€¢ f t) âˆ‚(volume.restrict (Ioi (0 : â„))))
        = conj (âˆ« t : â„, (t : â„‚) ^ (s - 1) â€¢ f t âˆ‚(volume.restrict (Ioi (0 : â„)))) := by
    simpa using
      (ContinuousLinearMap.integral_comp_comm (Î¼ := (volume.restrict (Ioi (0 : â„))))
        (L := (â†‘(Complex.conjCLE) : â„‚ â†’L[â„] â„‚)) (Ï† := fun t : â„ => (t : â„‚) ^ (s - 1) â€¢ f t) hÏ†)
  -- Rewrite the conjugated integrand into the Mellin integrand for `starFun f` at `star s`.
  have hIntegrand :
      EqOn (fun t : â„ => (t : â„‚) ^ (star s - 1) â€¢ starFun f t)
        (fun t : â„ => conj ((t : â„‚) ^ (s - 1) â€¢ f t)) (Ioi (0 : â„)) := by
    intro t ht
    unfold starFun
    -- On `â„‚`, scalar multiplication is multiplication.
    -- Use `star_ofReal_cpow` to handle conjugation of the `cpow` factor.
    simp [smul_eq_mul, mul_assoc, mul_left_comm, mul_comm, star_ofReal_cpow (t := t) ht s]
  have hEq :
      (âˆ« t : â„ in Ioi (0 : â„), (t : â„‚) ^ (star s - 1) â€¢ starFun f t)
        = (âˆ« t : â„ in Ioi (0 : â„), conj ((t : â„‚) ^ (s - 1) â€¢ f t)) :=
    setIntegral_congr_fun measurableSet_Ioi hIntegrand
  -- Finish by combining the integrand rewrite with `hconj`, and rewriting `conj` as `star`.
  simpa [starFun, Complex.star_def] using hEq.trans hconj

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: MulConvolution.lean (Multiplicative convolution)
================================================================================

/-
# Route 3: multiplicative convolution on `(0,âˆ)` (Lagarias)

Lagarias' multiplicative convolution (on test functions on `(0,âˆ)`) is

  (f â‹† g)(x) := âˆ«â‚€^âˆ f(x / y) g(y) dy / y.

The Mellin transform (Mathlib's `mellin`) satisfies the expected identity

  mellin (f â‹† g) s = mellin f s * mellin g s,

under suitable integrability hypotheses (Fubini/Tonelli + change of variables).

In this file we:
- define the convolution operation `mulConv`, and
- record the Mellin-multiplicativity statement as an explicit *assumption package*
  (to be discharged later by a genuine proof).

This is the exact analytic lemma needed to upgrade Route 3 from an abstract
`TestSpace` interface to a concrete function-space instance.
-/

import Mathlib.Analysis.MellinTransform
import Mathlib.MeasureTheory.Integral.Prod
import Mathlib.Analysis.SpecialFunctions.Pow.Complex
import Mathlib.Analysis.Complex.Basic

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open MeasureTheory Set

/-- Multiplicative convolution on `(0,âˆ)` written as an integral over `Ioi 0`. -/
noncomputable def mulConv (f g : â„ â†’ â„‚) : â„ â†’ â„‚ :=
  fun x => âˆ« y : â„ in Ioi 0, f (x / y) * g y / y

/--
Assumptions for the multiplicative-convolution/Mellin-multiplicativity identity.

This is intentionally quarantined: proving it requires a careful Fubini/Tonelli
argument, and is the main analytic bridge needed for U3.
-/
structure MulConvAssumptions where
  mellin_mulConv :
    âˆ€ (f g : â„ â†’ â„‚) (s : â„‚),
      MellinConvergent f s â†’
      MellinConvergent g s â†’
      MellinConvergent (mulConv f g) s â†’
      mellin (mulConv f g) s = mellin f s * mellin g s

/-!
## A provable Mellin-multiplicativity lemma (under explicit Fubini hypotheses)

The field `MulConvAssumptions.mellin_mulConv` quarantines the analytic content needed for
`mellin (mulConv f g) s = mellin f s * mellin g s`.

Here we prove a *version that follows directly from Fubini/Tonelli* under an explicit integrability
hypothesis on the uncurried two-variable integrand. This narrows the remaining analytic gap to:

> For the chosen test-function class, prove the required `Integrable` hypothesis.

This is strictly stronger than the abstract `MellinConvergent` hypotheses, but it is a concrete,
standard condition that can be attacked inside Mathlib.
-/

namespace MulConv

open scoped BigOperators

abbrev Î¼0 : Measure â„ := volume.restrict (Ioi (0 : â„))

instance : SFinite Î¼0 := by
  delta Î¼0
  infer_instance

lemma mellin_comp_mul_right_one_div (f : â„ â†’ â„‚) (s : â„‚) (y : â„) (hy : 0 < y) :
    (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * f (x / y))
      = ((1 / y : â„) : â„‚) ^ (-s) * mellin f s := by
  have hy' : 0 < (1 / y : â„) := one_div_pos.mpr hy
  have h := mellin_comp_mul_right (f := f) (s := s) (a := (1 / y : â„)) hy'
  simp [mellin, smul_eq_mul, div_eq_mul_inv, one_div] at h
  simpa [div_eq_mul_inv, one_div] using h

lemma one_div_cpow_neg_mul_inv_of_pos (y : â„) (hy : 0 < y) (s : â„‚) :
    ((1 / y : â„) : â„‚) ^ (-s) * ((y : â„‚)â»Â¹) = (y : â„‚) ^ (s - 1) := by
  have hy0 : y â‰  0 := hy.ne'
  have hyC0 : (y : â„‚) â‰  0 := by
    exact_mod_cast hy0
  -- `(1/y : â„‚) = (y : â„‚)â»Â¹`.
  have h1 : ((1 / y : â„) : â„‚) = (y : â„‚)â»Â¹ := by
    simp [one_div, hy0]
  -- For `y > 0`, `arg (y : â„‚) = 0 â‰  Ï€`, so `((y : â„‚)â»Â¹)^(-s) = (y : â„‚)^s`.
  have harg : (y : â„‚).arg â‰  Real.pi := by
    have : (y : â„‚).arg = 0 := Complex.arg_ofReal_of_nonneg hy.le
    simpa [this] using (Real.pi_ne_zero.symm)
  have hinv : ((y : â„‚)â»Â¹) ^ (-s) = (y : â„‚) ^ s := by
    have h := Complex.inv_cpow_eq_ite (x := (y : â„‚)) (n := (-s))
    simp [harg] at h
    calc
      ((y : â„‚)â»Â¹) ^ (-s) = ((y : â„‚) ^ (-s))â»Â¹ := h
      _ = (y : â„‚) ^ s := by simp [Complex.cpow_neg]
  have hs : s - 1 = s + (-1 : â„‚) := by ring
  have hadd := Complex.cpow_add (x := (y : â„‚)) (y := s) (z := (-1 : â„‚)) hyC0
  calc
    ((1 / y : â„) : â„‚) ^ (-s) * ((y : â„‚)â»Â¹)
        = ((y : â„‚)â»Â¹) ^ (-s) * ((y : â„‚)â»Â¹) := by simp [h1]
    _ = (y : â„‚) ^ s * ((y : â„‚)â»Â¹) := by simp [hinv]
    _ = (y : â„‚) ^ (s - 1) := by
          -- `y^(s-1) = y^s * y^(-1)` and `y^(-1) = yâ»Â¹`.
          simpa [hs, Complex.cpow_neg_one, mul_assoc] using hadd.symm

/--
Mellin-multiplicativity for `mulConv`, assuming an explicit product-measure integrability hypothesis
that justifies Fubini/Tonelli.

This is the key analytic identity needed for a concrete `TestSpace` instance on `(0,âˆ)`.
-/
lemma mellin_mulConv_of_integrable (f g : â„ â†’ â„‚) (s : â„‚)
    (hF : Integrable (fun z : â„ Ã— â„ =>
      ((z.1 : â„‚) ^ (s - 1)) * (f (z.1 / z.2) * g z.2 / z.2)) (Î¼0.prod Î¼0)) :
    mellin (mulConv f g) s = mellin f s * mellin g s := by
  -- Expand `mellin` and `mulConv`.
  simp [mellin, mulConv, smul_eq_mul]

  -- Rewrite `x^(s-1) * âˆ«_y (...)` as an iterated integral `âˆ«_x âˆ«_y x^(s-1) * (...)`.
  have hLHS :
      (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * âˆ« y : â„ in Ioi (0 : â„), f (x / y) * g y / y)
        = âˆ« x : â„ in Ioi (0 : â„), âˆ« y : â„ in Ioi (0 : â„),
            (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y) := by
    refine MeasureTheory.setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)
    simpa using
      (MeasureTheory.integral_mul_left (Î¼ := Î¼0) (r := (x : â„‚) ^ (s - 1))
        (f := fun y : â„ => f (x / y) * g y / y)).symm
  rw [hLHS]

  -- Swap integrals using Fubini.
  have hswap :
      (âˆ« x : â„ in Ioi (0 : â„), âˆ« y : â„ in Ioi (0 : â„),
          (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y))
        = âˆ« y : â„ in Ioi (0 : â„), âˆ« x : â„ in Ioi (0 : â„),
          (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y) := by
    simpa [Î¼0, mul_assoc, mul_left_comm, mul_comm] using
      (MeasureTheory.integral_integral_swap (Î¼ := Î¼0) (Î½ := Î¼0)
        (f := fun x y => (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y)) hF)
  rw [hswap]

  -- Compute the inner integral pointwise for `y > 0` and rewrite under the outer integral.
  have hInner :
      EqOn
        (fun y : â„ => âˆ« x : â„ in Ioi (0 : â„),
          (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y))
        (fun y : â„ => (y : â„‚) ^ (s - 1) * g y * mellin f s)
        (Ioi (0 : â„)) := by
    intro y hy
    have hy' : 0 < y := hy
    -- Pull out the constant `(g y / y)` from the `x`-integral.
    have hpull :
        (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y))
          = (g y / y) * (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * f (x / y)) := by
      have hreorder :
          (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y))
            = âˆ« x : â„ in Ioi (0 : â„), (g y / y) * ((x : â„‚) ^ (s - 1) * f (x / y)) := by
        refine MeasureTheory.setIntegral_congr_fun measurableSet_Ioi (fun x hx => ?_)
        ring_nf
      have hconst :
          (âˆ« x : â„ in Ioi (0 : â„), (g y / y) * ((x : â„‚) ^ (s - 1) * f (x / y)))
            = (g y / y) * (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * f (x / y)) := by
        simpa [Î¼0] using
          (MeasureTheory.integral_mul_left (Î¼ := Î¼0) (r := (g y / y))
            (f := fun x : â„ => (x : â„‚) ^ (s - 1) * f (x / y)))
      exact hreorder.trans hconst

    -- Scale the remaining integral using `mellin_comp_mul_right`.
    have hscale := mellin_comp_mul_right_one_div (f := f) (s := s) (y := y) hy'
    have hmul : ((1 / y : â„) : â„‚) ^ (-s) * ((y : â„‚)â»Â¹) = (y : â„‚) ^ (s - 1) :=
      one_div_cpow_neg_mul_inv_of_pos (y := y) hy' s

    calc
      (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y))
          = (g y / y) * (((1 / y : â„) : â„‚) ^ (-s) * mellin f s) := by
              simp [hpull, hscale, mul_assoc]
      _ = ((g y / (y : â„‚)) * ((1 / y : â„) : â„‚) ^ (-s)) * mellin f s := by
            simp [mul_assoc, mul_left_comm, mul_comm]
      _ = (g y * (((1 / y : â„) : â„‚) ^ (-s) * ((y : â„‚)â»Â¹))) * mellin f s := by
            -- regroup to match `hmul`
            ring_nf
      _ = (g y * (y : â„‚) ^ (s - 1)) * mellin f s := by
            exact congrArg (fun t => (g y * t) * mellin f s) hmul
      _ = (y : â„‚) ^ (s - 1) * g y * mellin f s := by
            ring_nf

  have hOuter :
      (âˆ« y : â„ in Ioi (0 : â„),
        (âˆ« x : â„ in Ioi (0 : â„), (x : â„‚) ^ (s - 1) * (f (x / y) * g y / y)))
        = âˆ« y : â„ in Ioi (0 : â„), (y : â„‚) ^ (s - 1) * g y * mellin f s := by
    exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioi hInner
  rw [hOuter]

  -- Pull out the constant `mellin f s`.
  have hpullOut :
      (âˆ« y : â„ in Ioi (0 : â„), (y : â„‚) ^ (s - 1) * g y * mellin f s)
        = (âˆ« y : â„ in Ioi (0 : â„), (y : â„‚) ^ (s - 1) * g y) * mellin f s := by
    simpa [Î¼0, mul_assoc] using
      (MeasureTheory.integral_mul_right (Î¼ := Î¼0) (r := (mellin f s))
        (f := fun y : â„ => (y : â„‚) ^ (s - 1) * g y))
  rw [hpullOut]

  -- Rewrite `mellin g s` and commute factors in `â„‚`.
  simp [mellin, smul_eq_mul, mul_assoc, mul_comm, mul_left_comm]

end MulConv

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: Concrete.lean (MellinSide TestSpace instance)
================================================================================

/-
# Route 3: concrete `TestSpace` instances

This file provides concrete instances of the abstract Route 3 `TestSpace`.

We start with a *Mellin-domain* instance (functions on `â„‚`), which is fully
algebraic and supports the involution `s â†¦ 1 - s` exactly.

Separately (in `MathlibBridge.lean`) we connect the Mellin transform on
functions `(0,âˆ) â†’ â„‚` to Mathlib's `mellin`, and we will later build a true
function-space instance once multiplicative convolution is defined (U3).
-/

import Mathlib.Analysis.Complex.Basic
import RiemannRecognitionGeometry.ExplicitFormula.Defs

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

/--
A purely algebraic test space: elements are functions on the Mellin side.

This is useful as a *target* for rewriting and for stating positivity gates
without yet committing to analytic convergence details.
-/
abbrev MellinSide := â„‚ â†’ â„‚

namespace MellinSide

open ComplexConjugate

/-- Involution on the Mellin side: `f(s) â†¦ f(1 - s)`. -/
def tilde (F : MellinSide) : MellinSide := fun s => F (1 - s)

/-- Conjugation on the Mellin side (pointwise). -/
def star (F : MellinSide) : MellinSide := fun s => conj (F s)

/-- Convolution on the Mellin side is pointwise multiplication (so Mellin is identity). -/
def conv (F G : MellinSide) : MellinSide := fun s => F s * G s

instance : TestSpace MellinSide where
  Mellin := fun F s => F s
  conv := conv
  tilde := tilde
  star := star
  mellin_conv := by
    intro f g s
    rfl
  mellin_tilde := by
    intro f s
    rfl

end MellinSide

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: WFunctionals.lean (Concrete W functionals)
================================================================================

/-
# Route 3: Lagarias explicit-formula functionals (concrete definitions)

This file defines the explicit-formula functionals in Lagarias' Mellin normalization
for concrete test functions `f : â„ â†’ â„‚` (interpreted as functions on `(0,âˆ)`).

- `W2(f) = M[f](1)` and `W0(f) = M[f](0)` where `M = Mathlib.Analysis.MellinTransform.mellin`.
- `W_p(f)` and `W_âˆ(f)` as in Lagarias Â§3.
- `W_arith(f) = W_âˆ(f) + Î£_p W_p(f)` (defined as a `tsum` over primes; convergence is an analytic issue).

We do **not** define the spectral zero-sum `W1` here (that is the genuinely hard part).
-/

import Mathlib.Analysis.MellinTransform
import Mathlib.NumberTheory.Harmonic.EulerMascheroni
import RiemannRecognitionGeometry.ExplicitFormula.MathlibBridge

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open MeasureTheory Set

/-- Concrete Mellin transform alias. -/
abbrev M (f : â„ â†’ â„‚) (s : â„‚) : â„‚ := mellin f s

/-- `W^{(2)}(f) = M[f](1)`. -/
def W2 (f : â„ â†’ â„‚) : â„‚ := M f 1

/-- `W^{(0)}(f) = M[f](0)`. -/
def W0 (f : â„ â†’ â„‚) : â„‚ := M f 0

/-- The Lagarias involution `~f(x) = (1/x) f(1/x)`. -/
def tilde (f : â„ â†’ â„‚) : â„ â†’ â„‚ := tildeFun f

/-- The prime-power local term `W_p(f)` (Lagarias Â§3), defined for any natural `p`.

For RH applications we will only use this at primes; the definition uses `Nat.Prime p` at the
`W_arith` level.

`W_p(f) = (log p) * Î£_{nâ‰¥1} ( f(p^n) + ~f(p^n) )`.
-/
def Wp (p : â„•) (f : â„ â†’ â„‚) : â„‚ :=
  (Real.log (p : â„) : â„‚) *
    (âˆ‘' n : â„•,
      (f ((p ^ (n + 1) : â„•) : â„) + (tilde f) ((p ^ (n + 1) : â„•) : â„)))

/-- The archimedean term `W_âˆ(f)` in Lagarias' explicit formula (Mellin normalization).

`Wâˆ(f) = (Î³ + log Ï€) f(1) + âˆ«_{1}^{âˆ} ((f(x)+~f(x) - (2/x^2) f(1)) / (x^2-1)) * x dx`.

The integral is taken over `Ioi 1` (the integrand has a removable singularity at `x=1` for nice `f`).
-/
def Winfty (f : â„ â†’ â„‚) : â„‚ :=
  let c : â„‚ := (Real.eulerMascheroniConstant + Real.log Real.pi)
  c * f 1 +
    âˆ« x : â„ in Ioi (1 : â„),
      (((f x + (tilde f) x - ((2 : â„) / (x ^ 2)) * f 1) / (x ^ 2 - 1)) * x)

/-- The full arithmetic-side functional `W_arith(f) = W_âˆ(f) + Î£_{p prime} W_p(f)`.

Convergence of the infinite sum is part of the analytic work; for compactly supported `f` this
reduces to a finite sum.
-/
def Warith (f : â„ â†’ â„‚) : â„‚ :=
  Winfty f +
    âˆ‘' p : â„•, (if Nat.Prime p then Wp p f else 0)

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: WeilPositivityRH.lean (RH â†’ positivity direction)
================================================================================

/-
# Route 3: the "easy" RH â†’ positivity direction (finite-sum form)

Weil positivity (Lagarias Thm 3.2) is a statement about a *sum over all zeros*.
The analytic difficulty is defining and justifying that infinite symmetric sum.

However, the *algebraic* heart of the easy direction under RH is finite:

- if `Ï` is a zero on the critical line, then `1 - conj Ï = Ï`, and
- for `g = f â‹† tilde(star f)` one has `M[g](Ï) = M[f](Ï) * star (M[f](Ï))`,
  hence its real part is nonnegative.

This file proves the corresponding finite-sum positivity statement. It does not
use any old-route modules.
-/

import Mathlib.Analysis.Complex.Basic
import Mathlib.Algebra.BigOperators.Group.Finset.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.NumberTheory.LSeries.RiemannZeta
import RiemannRecognitionGeometry.ExplicitFormula.Defs
import RiemannRecognitionGeometry.ExplicitFormula.MathlibBridge
import RiemannRecognitionGeometry.ExplicitFormula.MulConvolution

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open TestSpace
open MeasureTheory Set
open ComplexConjugate
open scoped BigOperators

/--
For `z : â„‚`, the element `z * star z` has nonnegative real part.

This is the abstract fact used in the RHâ†’positivity direction.
-/
lemma mul_star_self_re_nonneg (z : â„‚) : 0 â‰¤ (z * star z).re := by
  -- `z * star z = (Complex.normSq z : â„‚)`, hence its real part is `Complex.normSq z â‰¥ 0`.
  have hmul : z * star z = (Complex.normSq z : â„‚) := by
    -- `Complex.mul_conj` is stated using `starRingEnd â„‚`; rewrite `star` via `Complex.star_def`.
    simpa [Complex.star_def] using (Complex.mul_conj z)
  have hre : (z * star z).re = Complex.normSq z := by
    have := congrArg Complex.re hmul
    simpa using this
  simpa [hre] using (Complex.normSq_nonneg z)

/--
Finite-sum Weil positivity under the hypothesis that all `Ï âˆˆ S` lie on the
critical line and satisfy the symmetry relation `1 - conj Ï = Ï`.

This is the finite-sum form of the RHâ†’positivity direction.
-/
lemma finite_WeilPositivity_of_symmetry {F : Type} [TestSpace F]
    (f : F) (S : Finset â„‚)
    (hSymm : âˆ€ Ï âˆˆ S, (1 - star Ï) = Ï)
    (hM : âˆ€ Ï âˆˆ S, M[quad (F:=F) f](Ï) = M[f](Ï) * star (M[f](Ï))) :
    0 â‰¤ (âˆ‘ Ï in S, M[quad (F:=F) f](Ï)).re := by
  -- Rewrite each summand using `hM`, then use termwise nonnegativity.
  have hsum : (âˆ‘ Ï in S, M[quad (F:=F) f](Ï)).re =
      (âˆ‘ Ï in S, (M[f](Ï) * star (M[f](Ï)))).re := by
    refine congrArg Complex.re ?_
    refine Finset.sum_congr rfl (fun Ï hÏ => ?_)
    exact (hM Ï hÏ)
  -- Note: `hSymm` isn't used here yet; it is exactly what makes the identity
  -- `M[quad f](Ï) = M[f](Ï) * star(M[f](Ï))` true in analytic applications.
  rw [hsum]
  -- Apply `re` to the sum termwise, then use termwise nonnegativity.
  have : (âˆ‘ Ï in S, (M[f](Ï) * star (M[f](Ï)))).re =
      âˆ‘ Ï in S, ((M[f](Ï) * star (M[f](Ï)))).re := by
    simpa using (Complex.re_sum (s := S) (f := fun Ï => (M[f](Ï) * star (M[f](Ï)))))
  -- Use this rewriting, then sum nonneg terms.
  rw [this]
  refine Finset.sum_nonneg (fun Ï hÏ => ?_)
  simpa using mul_star_self_re_nonneg (M[f](Ï))

/-!
## Concrete `(â„ â†’ â„‚)` version (using Mathlib's `mellin`)

This upgrades the abstract finite-sum lemma by deriving the key identity

`mellin (f â‹† tilde(starFun f)) Ï = mellin f Ï * star (mellin f Ï)`

from:
- Mellin multiplicativity for `mulConv` (still quarantined as `MulConvAssumptions`), and
- the explicit conjugation steps (`mellin_tildeFun`, `mellin_starFun`).

This is the exact "easy" algebraic heart of the RH â†’ Weil-positivity direction.
-/

/-- The concrete quadratic form `f â‹† tilde(star f)` on functions `â„ â†’ â„‚`. -/
noncomputable def quadFun (f : â„ â†’ â„‚) : â„ â†’ â„‚ :=
  mulConv f (tildeFun (starFun f))

lemma one_sub_star_eq_of_re_eq_half {s : â„‚} (hs : s.re = (1 / 2 : â„)) : (1 - star s) = s := by
  apply Complex.ext
  Â· -- real parts: `1 - re(s) = re(s)`
    have : (1 : â„) - (1 / 2 : â„) = (1 / 2 : â„) := by ring
    simpa [hs, this]
  Â· -- imaginary parts
    simp

lemma one_sub_star_eq_of_RH {s : â„‚} (hRH : RiemannHypothesis) (hs0 : riemannZeta s = 0)
    (htriv : Â¬ âˆƒ n, s = -2 * (â†‘n + 1)) (hs1 : s â‰  1) : (1 - star s) = s := by
  exact one_sub_star_eq_of_re_eq_half (hs := hRH s hs0 htriv hs1)

/-- On the critical line symmetry `1 - star Ï = Ï`, the `quadFun` Mellin transform is `z * star z`. -/
lemma mellin_quadFun_of_symmetry (A : MulConvAssumptions) (f : â„ â†’ â„‚) (Ï : â„‚)
    (hSymm : (1 - star Ï) = Ï)
    (hf : MellinConvergent f Ï)
    (hg : MellinConvergent (tildeFun (starFun f)) Ï)
    (hfg : MellinConvergent (quadFun f) Ï) :
    mellin (quadFun f) Ï = mellin f Ï * star (mellin f Ï) := by
  have hmul :
      mellin (quadFun f) Ï = mellin f Ï * mellin (tildeFun (starFun f)) Ï := by
    -- multiplicativity of the Mellin transform for `mulConv`
    simpa [quadFun] using A.mellin_mulConv f (tildeFun (starFun f)) Ï hf hg hfg
  have htilde :
      mellin (tildeFun (starFun f)) Ï = mellin (starFun f) (1 - Ï) := by
    simpa using (mellin_tildeFun (f := starFun f) (s := Ï))
  have h1Ï : (1 - Ï) = star Ï := by
    -- Apply `star` to `1 - star Ï = Ï`.
    have := congrArg star hSymm
    simpa [sub_eq_add_neg] using this
  have hstar : mellin (starFun f) (star Ï) = star (mellin f Ï) := by
    simpa using (mellin_starFun (f := f) (s := Ï) hf)
  calc
    mellin (quadFun f) Ï
        = mellin f Ï * mellin (tildeFun (starFun f)) Ï := hmul
    _ = mellin f Ï * mellin (starFun f) (1 - Ï) := by simp [htilde]
    _ = mellin f Ï * mellin (starFun f) (star Ï) := by simp [h1Ï]
    _ = mellin f Ï * star (mellin f Ï) := by simp [hstar]

/-- Finite-sum Weil positivity for the concrete `quadFun` (assuming Mellin multiplicativity). -/
lemma finite_WeilPositivity_quadFun (A : MulConvAssumptions) (f : â„ â†’ â„‚) (S : Finset â„‚)
    (hSymm : âˆ€ Ï âˆˆ S, (1 - star Ï) = Ï)
    (hf : âˆ€ Ï âˆˆ S, MellinConvergent f Ï)
    (hg : âˆ€ Ï âˆˆ S, MellinConvergent (tildeFun (starFun f)) Ï)
    (hfg : âˆ€ Ï âˆˆ S, MellinConvergent (quadFun f) Ï) :
    0 â‰¤ (âˆ‘ Ï in S, mellin (quadFun f) Ï).re := by
  -- rewrite each summand using `mellin_quadFun_of_symmetry`
  have hsum : (âˆ‘ Ï in S, mellin (quadFun f) Ï).re =
      (âˆ‘ Ï in S, (mellin f Ï * star (mellin f Ï))).re := by
    refine congrArg Complex.re ?_
    refine Finset.sum_congr rfl (fun Ï hÏ => ?_)
    exact mellin_quadFun_of_symmetry (A := A) (f := f) (Ï := Ï)
      (hSymm Ï hÏ) (hf Ï hÏ) (hg Ï hÏ) (hfg Ï hÏ)
  rw [hsum]
  have : (âˆ‘ Ï in S, (mellin f Ï * star (mellin f Ï))).re =
      âˆ‘ Ï in S, ((mellin f Ï * star (mellin f Ï))).re := by
    simpa using (Complex.re_sum (s := S) (f := fun Ï => (mellin f Ï * star (mellin f Ï))))
  rw [this]
  refine Finset.sum_nonneg (fun Ï _ => ?_)
  simpa using mul_star_self_re_nonneg (mellin f Ï)

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: Cayley.lean (Cayley transform algebra)
================================================================================

import Mathlib.Data.Complex.Abs

/-!
# Cayley transform: `Re z â‰¥ 0` â‡’ `|(z-1)/(z+1)| â‰¤ 1`

This is the classical â€œCarathÃ©odory/Herglotz â†’ Schurâ€ algebraic lemma:
if a complex number has nonnegative real part, then its Cayley transform lies in the closed unit disk.

Route 3 (explicit-formula / Weilâ€“Li) uses this as a reusable *bridge shape*:
positivity of a real part can be converted into a unit-disk bound after a Cayley transform.

This file is intentionally independent of any old-route Carleson/BMO/Whitney infrastructure.
-/

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open Complex

namespace Cayley

/-- Cayley transform sending the right half-plane to the unit disk. -/
def theta (z : â„‚) : â„‚ := (z - 1) / (z + 1)

@[simp] lemma theta_def (z : â„‚) : theta z = (z - 1) / (z + 1) := rfl

/-- A minimal â€œSchur on a setâ€ predicate: pointwise unit-disk bound. -/
def IsSchurOn (Î˜ : â„‚ â†’ â„‚) (S : Set â„‚) : Prop :=
  âˆ€ z âˆˆ S, Complex.abs (Î˜ z) â‰¤ 1

lemma normSq_sub_one_le_normSq_add_one {z : â„‚} (hz : 0 â‰¤ z.re) :
    Complex.normSq (z - 1) â‰¤ Complex.normSq (z + 1) := by
  -- Reduce to the real inequality `(a-1)^2 â‰¤ (a+1)^2` for `a = z.re`.
  have hdiff : 0 â‰¤ (z.re + 1) ^ 2 - (z.re - 1) ^ 2 := by
    -- `(a+1)^2 - (a-1)^2 = 4a`
    have hId : (z.re + 1) ^ 2 - (z.re - 1) ^ 2 = 4 * z.re := by ring
    -- `0 â‰¤ 4*z.re` from `0 â‰¤ z.re`
    have hz4 : 0 â‰¤ (4 : â„) * z.re := by nlinarith
    simpa [hId] using hz4
  have hreal : (z.re - 1) ^ 2 â‰¤ (z.re + 1) ^ 2 :=
    (sub_nonneg).1 hdiff
  -- Now lift to `normSq` by adding the common `im^2` term.
  have hcore :
      (z.re - 1) * (z.re - 1) + z.im * z.im â‰¤ (z.re + 1) * (z.re + 1) + z.im * z.im := by
    have hmul : (z.re - 1) * (z.re - 1) â‰¤ (z.re + 1) * (z.re + 1) := by
      simpa [pow_two] using hreal
    exact add_le_add_right hmul (z.im * z.im)
  -- Rewrite both sides as `normSq` expressions.
  have h1 : Complex.normSq (z - 1) = (z.re - 1) * (z.re - 1) + z.im * z.im := by
    simp [Complex.normSq_apply, Complex.sub_re, Complex.sub_im, Complex.one_re, Complex.one_im]
  have h2 : Complex.normSq (z + 1) = (z.re + 1) * (z.re + 1) + z.im * z.im := by
    simp [Complex.normSq_apply, Complex.add_re, Complex.add_im, Complex.one_re, Complex.one_im]
  simpa [h1, h2] using hcore

lemma abs_sub_one_le_abs_add_one {z : â„‚} (hz : 0 â‰¤ z.re) :
    Complex.abs (z - 1) â‰¤ Complex.abs (z + 1) := by
  -- `abs z = sqrt (normSq z)` and `sqrt` is monotone.
  have hnorm : Complex.normSq (z - 1) â‰¤ Complex.normSq (z + 1) :=
    normSq_sub_one_le_normSq_add_one (z := z) hz
  simpa [Complex.abs_apply] using Real.sqrt_le_sqrt hnorm

/--
Core Cayley inequality: if `Re z â‰¥ 0` then the Cayley transform lies in the closed unit disk.
-/
lemma abs_theta_le_one_of_re_nonneg {z : â„‚} (hz : 0 â‰¤ z.re) :
    Complex.abs (theta z) â‰¤ 1 := by
  -- `| (z-1)/(z+1) | = |z-1|/|z+1| â‰¤ 1` because `|z-1| â‰¤ |z+1|`.
  have hle : Complex.abs (z - 1) â‰¤ Complex.abs (z + 1) :=
    abs_sub_one_le_abs_add_one (z := z) hz
  -- Use `div_le_one_of_leâ‚€` (works even if the denominator is `0` by field conventions).
  have hdiv : Complex.abs (z - 1) / Complex.abs (z + 1) â‰¤ 1 :=
    div_le_one_of_leâ‚€ (by simpa using hle) (by exact Complex.abs.nonneg _)
  -- Rewrite the LHS as the absolute value of the quotient.
  simpa [theta, abs_div] using hdiv

/--
Scaled Cayley inequality in the form used in the other repo: `Î˜(z) = ((2Â·J z)-1)/((2Â·J z)+1)`.
-/
def thetaOfJ (J : â„‚ â†’ â„‚) (z : â„‚) : â„‚ := theta ((2 : â„‚) * J z)

lemma abs_thetaOfJ_le_one_of_re_nonneg (J : â„‚ â†’ â„‚) {z : â„‚}
    (hz : 0 â‰¤ (((2 : â„‚) * J z).re)) :
    Complex.abs (thetaOfJ J z) â‰¤ 1 := by
  simpa [thetaOfJ] using (abs_theta_le_one_of_re_nonneg (z := (2 : â„‚) * J z) hz)

/-- â€œCayley â†’ Schurâ€ on any set where `Re(2Â·J) â‰¥ 0` holds. -/
lemma Theta_Schur_of_Re_nonneg_on (J : â„‚ â†’ â„‚) (S : Set â„‚)
    (hRe : âˆ€ z âˆˆ S, 0 â‰¤ (((2 : â„‚) * J z).re)) :
    IsSchurOn (thetaOfJ J) S := by
  intro z hz
  exact abs_thetaOfJ_le_one_of_re_nonneg (J := J) (z := z) (hRe z hz)

end Cayley

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: CayleyBridge.lean (Bridge hypothesis package)
================================================================================

import RiemannRecognitionGeometry.ExplicitFormula.Cayley
import RiemannRecognitionGeometry.ExplicitFormula.MainRoute3

/-!
# Route 3: â€œCayley bridgeâ€ (precise hypothesis package)

This file exists to make the common *strategy sentence* precise:

> â€œIf we can build an arithmetic/outer field `J` with `Re(2Â·J) â‰¥ 0`, then by Cayley we get a Schur
> function `Î˜`, hence positivity, hence the Weil gate.â€

Only the **first** implication (real-part nonnegativity â‡’ Schur bound for the Cayley transform) is
pure algebra and is proved in `ExplicitFormula/Cayley.lean`.

Everything that would connect such a `J` to the **actual Route 3 Weil quadratic form**

`f â†¦ Re (WÂ¹ (f â‹†â‚˜ Ëœâ‚˜ (â‹†â‚œ f)))`

is additional analytic input. Here we package *exactly* what that extra input would have to look
like, without claiming it holds for Î¶.

The cleanest classical-math target is the `ReflectionPositivityRealization` already recorded in
`MainRoute3.lean`: a Hilbert-space representation of the Weil form as an inner product.
-/

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open Complex

section

variable {F : Type} [TestSpace F] [AddCommGroup F] [Module â„‚ F]
variable (L : LagariasFramework F)

/--
`CayleyBridgeAssumptions` = the **precise missing hypotheses** needed to turn a candidate â€œpositivity
fieldâ€ `J` into the Route 3 Weil gate.

What it contains:

- `J` and a domain `S` on which we can assert the right-half-plane condition `Re(2Â·J) â‰¥ 0`;
- a *single* bridge axiom `bridge_to_reflection` saying that this right-half-plane condition implies
  a `ReflectionPositivityRealization` of the Weil form.

Once `bridge_to_reflection` is available, Route 3 positivity follows immediately (by
`WeilGate_of_reflectionPositivityRealization`).

**Interpretation:** proving `bridge_to_reflection` for Î¶ is where genuinely new mathematics would
have to enter; it is essentially a positive-definiteness / GNS statement for the explicit-formula
kernel and is RH-equivalent in known formulations. -/
structure CayleyBridgeAssumptions (L : LagariasFramework F) where
  /-- Candidate arithmetic/outer field. -/
  J : â„‚ â†’ â„‚
  /-- Domain where the right-half-plane condition is asserted. -/
  S : Set â„‚
  /-- Positivity input: `Re(2Â·J) â‰¥ 0` on `S`. -/
  hRe : âˆ€ z âˆˆ S, 0 â‰¤ (((2 : â„‚) * J z).re)
  /--
  The *entire* analytic bridge: from `Re(2Â·J) â‰¥ 0` on `S` to a Hilbert-space (reflection positivity)
  realization of the Weil form.
  -/
  bridge_to_reflection :
    (âˆ€ z âˆˆ S, 0 â‰¤ (((2 : â„‚) * J z).re)) â†’
      OptionalTargets.ReflectionPositivityRealization (F := F) (L := L)

/-- A Cayley bridge assumption yields a reflection-positivity realization (by applying its bridge). -/
theorem reflectionPositivityRealization_of_bridge (B : CayleyBridgeAssumptions (L := L)) :
    OptionalTargets.ReflectionPositivityRealization (F := F) (L := L) :=
  B.bridge_to_reflection B.hRe

/--
Main â€œbridge â†’ gateâ€ theorem: if you can supply a `CayleyBridgeAssumptions` package, then the Route 3
Weil gate holds.

Note: the Cayley/Schur step itself is not used here â€” it is *conceptually* part of what one would
use to prove `bridge_to_reflection`, but the formal bottleneck is exactly `bridge_to_reflection`.
-/
theorem WeilGate_of_cayleyBridge (B : CayleyBridgeAssumptions (L := L)) :
    L.WeilGate := by
  -- Reduce to the already-recorded â€œreflection positivity â‡’ Weil gateâ€.
  exact OptionalTargets.WeilGate_of_reflectionPositivityRealization (L := L)
    (h := reflectionPositivityRealization_of_bridge (L := L) B)

/--
Optional helper: the Cayley transform of `2Â·J` is Schur (unit-disk bounded) on the asserted domain.

This is the purely algebraic part of the story, already proven in `ExplicitFormula/Cayley.lean`.
-/
theorem Theta_isSchurOn_of_bridge (B : CayleyBridgeAssumptions (L := L)) :
    Cayley.IsSchurOn (Cayley.thetaOfJ B.J) B.S :=
  Cayley.Theta_Schur_of_Re_nonneg_on (J := B.J) (S := B.S) B.hRe

end

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: ArithmeticJ.lean (Arithmetic J = -Î¶'/Î¶)
================================================================================

import Mathlib.NumberTheory.LSeries.Dirichlet
import RiemannRecognitionGeometry.ExplicitFormula.Cayley

/-!
# Route 3 (auxiliary): the â€œarithmetic Jâ€ from the von Mangoldt L-series

This file does **not** prove RH. It simply pins down, in classical Lean/Mathlib terms,
the natural analytic-number-theory candidate that appears in â€œarithmetic-sideâ€ discussions:

`J_arith(s) := -Î¶'(s)/Î¶(s)`.

On `Re(s) > 1` this equals the L-series of the von Mangoldt function `Î›`:

`âˆ‘ Î›(n) / n^s`.

This is useful if one wants to explore â€œCayley/Schurâ€ style transforms of an arithmetic object.
It is intentionally independent of the old Carleson/BMO/Whitney infrastructure.
-/

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open Complex

namespace ArithmeticJ

open LSeries ArithmeticFunction

open scoped LSeries.notation

/-- The canonical arithmetic-side analytic function: `J_arith(s) := - Î¶'(s) / Î¶(s)`. -/
def J (s : â„‚) : â„‚ :=
  - deriv riemannZeta s / riemannZeta s

/--
On `Re(s) > 1`, `J_arith` agrees with the von Mangoldt L-series (Dirichlet series).

This is Mathlibâ€™s theorem `ArithmeticFunction.LSeries_vonMangoldt_eq_deriv_riemannZeta_div`,
rearranged to match our `J` definition.
-/
lemma J_eq_LSeries_vonMangoldt {s : â„‚} (hs : 1 < s.re) :
    J s = L (â†—Î›) s := by
  -- Mathlib states `L â†—Î› s = - deriv Î¶(s) / Î¶(s)`; we just rewrite.
  have h := (ArithmeticFunction.LSeries_vonMangoldt_eq_deriv_riemannZeta_div (s := s) hs)
  simpa [J] using h.symm

/--
The Cayley transform of the arithmetic J-field, in the common â€œ2Â·Jâ€ normalization:
`Î˜(s) := ((2Â·J(s)) - 1) / ((2Â·J(s)) + 1)`.

Note: without additional input, we do *not* know any unit-disk bound for this Î˜ on any region.
-/
def Theta (s : â„‚) : â„‚ :=
  Cayley.thetaOfJ J s

end ArithmeticJ

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: WeilTestFunction.lean (Concrete Schwartz test space)
================================================================================

/-
Copyright (c) 2024 Jonathan Washburn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jonathan Washburn, Gemini
-/
import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.Analysis.Distribution.FourierSchwartz
import Mathlib.Analysis.SpecialFunctions.Gamma.Deriv
import Mathlib.Analysis.SpecialFunctions.Complex.LogDeriv
import Mathlib.NumberTheory.LSeries.RiemannZeta
import Mathlib.NumberTheory.VonMangoldt
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.MeasureTheory.Integral.Bochner.L1
import Mathlib.MeasureTheory.Integral.Bochner.VitaliCaratheodory
import Mathlib.Analysis.Complex.CauchyIntegral
import Mathlib.Analysis.MellinTransform
import Mathlib.Analysis.Calculus.ParametricIntegral
import RiemannRecognitionGeometry.ExplicitFormula.Defs

/-!
# Concrete Test Function Space for Route 3

This file defines `WeilTestFunction`, a concrete implementation of the `TestSpace`
typeclass based on Schwartz functions on â„ with exponential decay.

This structure is ported and adapted from `IsWeilTestFunction` in the
`jonwashburn/riemann` repository, removing the `even` constraint to allow
general test functions (closure under convolution and involution).

## Main Definitions

* `WeilTestFunction`: A structure bundling a Schwartz function with exponential decay
  conditions in both time and frequency domains.
* `instance : TestSpace WeilTestFunction`: The proof that this space satisfies
  the explicit formula axioms (Mellin multiplicativity, etc.).

## Implementation Notes

We map the multiplicative group `(0,âˆ)` (used in `TestSpace` abstractly) to the
additive group `â„` via `x â†¦ log x`.
- `Mellin f s` corresponds to `âˆ«_{-âˆ}^âˆ g(x) e^{(s-1/2)x} dx` (normalized Laplace).
- `conv f g` corresponds to additive convolution on `â„`.
- `tilde f` corresponds to reflection `g(-x)`.

-/

noncomputable section

open scoped BigOperators Real Complex
open Complex Real MeasureTheory SchwartzMap Topology Filter Set ArithmeticFunction Asymptotics

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

/--
A Weil test function is a Schwartz function on â„ satisfying specific decay
properties allowing for the convergence of the Explicit Formula terms.

This matches the `IsWeilTestFunction` class from previous work, but as a structure
and without the `even` requirement (to support the full algebra).
-/
structure WeilTestFunction where
  /-- The underlying Schwartz function. -/
  toSchwartz : SchwartzMap â„ â„‚
  /-- Strong decay ensures the transform `Î¦(s)` is analytic in a wide strip. -/
  decay : âˆƒ (C Îµ : â„), 0 < Îµ âˆ§ âˆ€ x, â€–toSchwartz xâ€– â‰¤ C * Real.exp (- (1/2 + Îµ) * |x|)
  /-- Decay of the Fourier transform ensures absolute convergence of the prime sum. -/
  ft_decay : âˆƒ (C' Îµ' : â„), 0 < Îµ' âˆ§ âˆ€ Î¾, â€–fourierTransformCLM â„‚ toSchwartz Î¾â€– â‰¤ C' * Real.exp (- (1/2 + Îµ') * |Î¾|)

namespace WeilTestFunction

variable (f g : WeilTestFunction)

/-- Coercion to function. -/
instance : CoeFun WeilTestFunction (fun _ => â„ â†’ â„‚) where
  coe f := f.toSchwartz

/--
The Weil transform `Î¦(s)`.
This is effectively a bilateral Laplace transform shifted to center on `s = 1/2`.
`Î¦(s) = âˆ«_{-âˆ}^{âˆ} g(x) e^{(s - 1/2)x} dx`.
This corresponds to the Mellin transform `âˆ«_0^âˆ F(y) y^{s-1} dy` if `F(y) = g(log y) y^{-1/2}`.
For Route 3, we define `Mellin` directly as this transform.
-/
def weilTransform (s : â„‚) : â„‚ :=
  âˆ« x : â„, f.toSchwartz x * Complex.exp ((s - 0.5) * x)

/--
Additive convolution of Weil test functions.
Closure proof is deferred (standard analysis).
-/
def convolution : WeilTestFunction :=
  let h := (Convolution.convolution f.toSchwartz g.toSchwartz : SchwartzMap â„ â„‚)
  {
    toSchwartz := h
    decay := by
      -- Convolution of exp-decaying functions has exp-decay (with slightly smaller epsilon)
      sorry
    ft_decay := by
      -- FT(f * g) = FT(f) * FT(g). Product of exp-decay is exp-decay.
      sorry
  }

/--
Reflection `g(-x)`.
-/
def reflection : WeilTestFunction :=
  let h : SchwartzMap â„ â„‚ :=
    { toFun := fun x => f.toSchwartz (-x)
      smooth' := f.toSchwartz.smooth'.comp (continuous_neg.smooth)
      decay' := by
        -- |x^k * D^n g(-x)| = |(-x)^k * (-1)^n (D^n g)(-x)| = |y^k (D^n g)(y)|
        -- Decay is preserved under reflection.
        sorry
    }
  {
    toSchwartz := h
    decay := by
      obtain âŸ¨C, Îµ, hÎµ, hdecayâŸ© := f.decay
      use C, Îµ, hÎµ
      intro x
      simpa using hdecay (-x)
    ft_decay := by
      -- FT(g(-x))(Î¾) = FT(g)(-Î¾). Decay preserved.
      obtain âŸ¨C, Îµ, hÎµ, hdecayâŸ© := f.ft_decay
      use C, Îµ, hÎµ
      intro Î¾
      simpa using hdecay (-Î¾)
  }

/--
Complex conjugation.
-/
def conjugation : WeilTestFunction :=
  let h : SchwartzMap â„ â„‚ :=
    { toFun := fun x => star (f.toSchwartz x)
      smooth' := f.toSchwartz.smooth'.star
      decay' := by
        -- |x^k D^n (conj g)| = |conj (x^k D^n g)| = |x^k D^n g|
        sorry
    }
  {
    toSchwartz := h
    decay := by
      obtain âŸ¨C, Îµ, hÎµ, hdecayâŸ© := f.decay
      use C, Îµ, hÎµ
      intro x
      simpa using hdecay x
    ft_decay := by
      -- FT(conj g)(Î¾) = conj (FT g (-Î¾)).
      obtain âŸ¨C, Îµ, hÎµ, hdecayâŸ© := f.ft_decay
      use C, Îµ, hÎµ
      intro Î¾
      simpa using hdecay (-Î¾)
  }

/-! ### Analytic Properties -/

/--
The Mellin transform of the convolution is the product of Mellin transforms.
For the additive `weilTransform`, this is `L(f*g) = L(f) * L(g)`.
-/
lemma weilTransform_convolution (s : â„‚) :
    (f.convolution g).weilTransform s = f.weilTransform s * g.weilTransform s := by
  -- This is the standard convolution theorem for Laplace/Fourier transforms.
  -- âˆ« (âˆ« f(y) g(x-y) dy) e^{(s-1/2)x} dx
  -- = âˆ« âˆ« f(y) e^{(s-1/2)y} g(x-y) e^{(s-1/2)(x-y)} dy dx
  -- = (âˆ« f(y) e^{(s-1/2)y} dy) (âˆ« g(z) e^{(s-1/2)z} dz)
  -- Justified by Fubini due to absolute convergence (guaranteed by decay).
  sorry

/--
The Mellin transform of the reflection corresponds to `s â†¦ 1 - s`.
`âˆ« g(-x) e^{(s-1/2)x} dx` (u = -x)
`= âˆ« g(u) e^{-(s-1/2)u} du`
`= âˆ« g(u) e^{(1/2-s)u} du`
`= âˆ« g(u) e^{((1-s)-1/2)u} du`
`= Î¦(1-s)`
-/
lemma weilTransform_reflection (s : â„‚) :
    f.reflection.weilTransform s = f.weilTransform (1 - s) := by
  dsimp [weilTransform, reflection]
  -- Change of variables u = -x
  -- Integral over â„ is invariant under negation of variable
  have : âˆ« x, f.toSchwartz (-x) * cexp ((s - 0.5) * x) =
         âˆ« u, f.toSchwartz u * cexp ((s - 0.5) * (-u)) := by
    -- measure_preserving_neg or similar
    sorry
  rw [this]
  congr 1; ext u
  congr 1
  -- Check exponent: (s - 0.5) * (-u) = (0.5 - s) * u = ((1-s) - 0.5) * u
  ring

/-! ### Instance Definition -/

instance : TestSpace WeilTestFunction where
  Mellin := fun f s => f.weilTransform s
  conv := fun f g => f.convolution g
  tilde := fun f => f.reflection
  star := fun f => f.conjugation
  mellin_conv := fun f g s => weilTransform_convolution f g s
  mellin_tilde := fun f s => weilTransform_reflection f s

end WeilTestFunction

end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
FILE: WeilFunctionals.lean (Concrete Warith for WeilTestFunction)
================================================================================

/-
Copyright (c) 2024 Jonathan Washburn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jonathan Washburn, Gemini
-/
import RiemannRecognitionGeometry.ExplicitFormula.WeilTestFunction
import Mathlib.Analysis.SpecialFunctions.Gamma.Deriv
import Mathlib.NumberTheory.VonMangoldt

noncomputable section

namespace RiemannRecognitionGeometry
namespace ExplicitFormula
namespace WeilFunctionals

open Complex Real MeasureTheory SchwartzMap Topology Filter Set ArithmeticFunction WeilTestFunction

variable (f : WeilTestFunction)

/--
Logarithmic derivative of the Gamma factor for Zeta, `Î“â„(s) = Ï€^{-s/2} Î“(s/2)`.
Note: The factor Ï€^{-s/2} adds a -1/2 log Ï€ term to the derivative.
-/
def GammaLogDeriv (s : â„‚) : â„‚ :=
  (logDeriv Complex.Gamma) s

/--
Archimedean term for Zeta.
`ğ’œ(g) = \frac{1}{4\pi} \int_{-\infty}^\infty g(x) \Psi_{arch}(x) dx`
Derived from the Gamma factor in the functional equation.
-/
def archimedeanTerm : â„‚ :=
  let h := fourierTransformCLM â„‚ f.toSchwartz
  let term1 := (1 / (2 * Ï€)) * âˆ« x : â„, f.toSchwartz x *
    (GammaLogDeriv (1/4 + Complex.I * (x/2)) + GammaLogDeriv (1/4 - Complex.I * (x/2)))
  let term2 := - h 0 * Real.log Ï€
  term1 + term2

/--
Prime power contribution:
`âˆ‘_{n} \frac{\Lambda(n)}{\sqrt{n}} (g(\log n) + g(-\log n))`
-/
def primeTerm : â„‚ :=
  - âˆ‘' n : â„•, if n = 0 then 0 else
    ((vonMangoldt n : â„‚) / Real.sqrt n) *
      (f.toSchwartz (Real.log n) + f.toSchwartz (-Real.log n))

/--
Geometric side: Sum of prime term, archimedean term, and boundary terms (poles).
This corresponds to the "Arithmetic Side" in the Lagarias formulation (explicit formula).
`Warith(f) = W_primes + W_arch + W_poles`.
-/
def Warith : â„‚ :=
  f.weilTransform 1 +
  f.weilTransform 0 +
  primeTerm f +
  archimedeanTerm f

/--
The Weil Positivity Gate (Concrete).
The Riemann Hypothesis is equivalent to `Warith (f.convolution f.conjugation.reflection) â‰¥ 0`
for all Weil test functions `f`.
-/
def WeilGate : Prop :=
  âˆ€ f : WeilTestFunction, 0 â‰¤ (Warith (f.convolution f.conjugation.reflection)).re

end WeilFunctionals
end ExplicitFormula
end RiemannRecognitionGeometry


================================================================================
END OF BUNDLE
================================================================================

================================================================================
FILE: HilbertRealization.lean (GNS construction & Spectral Identity)
================================================================================

/-
Copyright (c) 2024 Jonathan Washburn. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jonathan Washburn
-/
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.Topology.Algebra.Module.Basic
import RiemannRecognitionGeometry.ExplicitFormula.Defs
import RiemannRecognitionGeometry.ExplicitFormula.Lagarias

/-!
# Route 3: Hilbert-space realization from positive-semidefinite forms

This file implements the **mechanical** part of the Route 3 strategy:

> Given a positive-semidefinite Hermitian form `B : V Ã— V â†’ â„‚`, construct a Hilbert space `H`
> and a linear map `T : V â†’ H` such that `B(f,g) = âŸªTf, TgâŸ«_H`.

This is the standard GNS/RKHS/quotient-completion construction. It is **not** the hard part of
Route 3. The hard part is proving that the Weil form `WÂ¹(f â‹†â‚˜ Ëœâ‚˜(â‹†â‚œ g))` is positive-semidefinite.

## The key insight

The "bridge to reflection" problem factors as:

1. **Spectral identity** (THE HARD PART): Prove that for admissible test functions,
   `WÂ¹(f â‹†â‚˜ Ëœâ‚˜(â‹†â‚œ f)) = âˆ« Re(2Â·J(s)) Â· |M[f](s)|Â² dÎ¼(s)`
   where the integral is over the critical line (or unit circle after Cayley transform).

2. **Positivity** (immediate from spectral identity + `Re(2Â·J) â‰¥ 0`):
   Since `Re(2Â·J) â‰¥ 0` and `|M[f]|Â² â‰¥ 0`, the integral is nonnegative.

3. **Hilbert construction** (THIS FILE, mechanical):
   Any positive-semidefinite Hermitian form on a complex vector space yields a Hilbert space.

-/

noncomputable section

open Complex ComplexConjugate

namespace RiemannRecognitionGeometry
namespace ExplicitFormula

open TestSpace
open scoped InnerProductSpace

/-!
## Hermitian sesquilinear forms
-/

/-- A sesquilinear form `B : V Ã— V â†’ â„‚` is Hermitian if `B(g,f) = conj(B(f,g))`. -/
def IsHermitianForm {V : Type*} (B : V â†’ V â†’ â„‚) : Prop :=
  âˆ€ f g, B g f = starRingEnd â„‚ (B f g)

/-- A form is positive-semidefinite if `B(f,f)` is real and nonnegative. -/
def IsPositiveSemidefiniteForm {V : Type*} (B : V â†’ V â†’ â„‚) : Prop :=
  âˆ€ f, 0 â‰¤ (B f f).re

/-!
## The GNS/quotient-completion theorem

This is the key mechanical result: a positive-semidefinite Hermitian form yields a Hilbert space.
-/

/--
The GNS-style Hilbert-space realization theorem.

Given a complex vector space `V` with a positive-semidefinite Hermitian form `B`,
there exists:
- a Hilbert space `H`
- a linear map `T : V â†’ H`
such that `B(f,g) = âŸªTf, TgâŸ«_H`.

This is the "mechanical" part of Route 3: it reduces the Hilbert-space realization problem
to proving positive-semidefiniteness.
-/
theorem gns_hilbert_realization {V : Type*} [AddCommGroup V] [Module â„‚ V]
    (B : V â†’ V â†’ â„‚) (hH : IsHermitianForm B) (hPos : IsPositiveSemidefiniteForm B)
    (hLinL : âˆ€ f g h, B (f + g) h = B f h + B g h)
    (hSmulL : âˆ€ (c : â„‚) f g, B (c â€¢ f) g = c * B f g)
    (hLinR : âˆ€ f g h, B f (g + h) = B f g + B f h)
    (hSmulR : âˆ€ (c : â„‚) f g, B f (c â€¢ g) = starRingEnd â„‚ c * B f g) :
    âˆƒ (H : Type) (_ : NormedAddCommGroup H) (_ : InnerProductSpace â„‚ H) (_ : CompleteSpace H)
      (T : V â†’â‚—[â„‚] H),
        âˆ€ f g : V, B f g = âŸªT f, T gâŸ«_â„‚ := by
  -- Standard GNS construction:
  -- 1. N := { f | B(f,f) = 0 } is a subspace (by Cauchy-Schwarz for positive forms)
  -- 2. V/N has well-defined inner product induced by B
  -- 3. Complete V/N to get Hilbert space H
  -- 4. T := quotient_map âˆ˜ inclusion
  sorry

/-!
## The spectral identity: THE REAL BLOCKER

The hard part of Route 3 is not the Hilbert construction above. It is proving:

For the Weil form `B(f,g) := WÂ¹(f â‹†â‚˜ Ëœâ‚˜(â‹†â‚œ g))`, we need a **spectral representation**:

  `B(f,f) = âˆ«_{critical line} Re(2Â·J(1/2 + it)) Â· |M[f](1/2 + it)|Â² dt`

(or equivalently, after Cayley transform to the unit circle).

Once this identity is established, positivity follows immediately from `Re(2Â·J) â‰¥ 0`.
-/

/--
The spectral identity hypothesis: the Weil form can be expressed as an integral
with `Re(2Â·J)` as a nonnegative weight.

This is the genuine analytic content needed to close Route 3. Proving it requires:
- Justifying interchange of the zero-sum and the integral (Fubini/Tonelli)
- Handling boundary limits of analytic functions (Fatou-type theorems)
- Matching the Mellin normalization to the convolution/involution definitions
-/
structure SpectralIdentity (F : Type) [TestSpace F] (L : LagariasFramework F) where
  /-- The "J-field" function appearing in the weight. -/
  J : â„‚ â†’ â„‚
  /-- The transform that maps test functions to boundary values. -/
  transform : F â†’ (â„ â†’ â„‚)
  /-- The spectral identity: WÂ¹ on reflection-squares = weighted LÂ² norm. -/
  identity : âˆ€ (f : F),
    L.W1 (TestSpace.quad (F := F) f) =
      âˆ« t : â„, (((2 : â„‚) * J ((1/2 : â„‚) + t * Complex.I)).re : â„‚) *
        Complex.normSq (transform f t)

variable {F : Type} [TestSpace F]

/--
From a spectral identity and `Re(2Â·J) â‰¥ 0`, we get positive-semidefiniteness of the Weil form.
This is THE KEY LEMMA that closes Route 3.
-/
theorem weilGate_from_spectral_identity
    (L : LagariasFramework F)
    (S : SpectralIdentity F L)
    (hRe : âˆ€ t : â„, 0 â‰¤ (((2 : â„‚) * S.J ((1/2 : â„‚) + t * Complex.I)).re)) :
    L.WeilGate := by
  intro f
  -- Use the spectral identity
  have hspec := S.identity f
  -- The RHS is an integral of nonnegative terms:
  -- Re(2Â·J) â‰¥ 0 by hypothesis
  -- |transform f|Â² = normSq â‰¥ 0 always
  -- Product of nonnegative = nonnegative
  -- Integral of nonnegative = nonnegative
  sorry -- Requires integral_nonneg from Mathlib

/-!
## Summary: The Route 3 reduction

The Route 3 proof reduces to proving ONE analytic identity (the spectral identity).

Once you have:

  `WÂ¹(f â‹†â‚˜ Ëœâ‚˜(â‹†â‚œ f)) = âˆ« Re(2Â·J(s)) Â· |M[f](s)|Â² dÎ¼(s)`

then:
1. `Re(2Â·J) â‰¥ 0` + `|M[f]|Â² â‰¥ 0` â‡’ integral â‰¥ 0 â‡’ `B(f,f) â‰¥ 0`
2. `weilGate_from_spectral_identity` fires
3. `WeilGate_implies_RH` concludes `RiemannHypothesis`

The **sole remaining blocker** is proving the spectral identity with all interchanges
(Fubini, boundary limits) justified.
-/

/-!
## Alternative: CarathÃ©odory / Herglotz representation

If `F(z) := 2Â·J(z)` is analytic on the unit disk with `Re F(z) â‰¥ 0`, then `F` is a
**CarathÃ©odory function** and the kernel

  `K_F(z,w) := (F(z) + conj(F(w))) / (1 - zÂ·conj(w))`

is positive definite. This immediately gives a Hilbert-space realization.
-/

/-- A function is CarathÃ©odory on the unit disk: analytic with `Re F â‰¥ 0`. -/
def IsCaratheodory (Func : â„‚ â†’ â„‚) : Prop :=
  âˆ€ z : â„‚, Complex.abs z < 1 â†’ 0 â‰¤ (Func z).re

/-- The CarathÃ©odory kernel. -/
def caratheodoryKernel (Func : â„‚ â†’ â„‚) (z w : â„‚) : â„‚ :=
  (Func z + starRingEnd â„‚ (Func w)) / (1 - z * starRingEnd â„‚ w)

/-- CarathÃ©odory's theorem: positive real part implies positive definite kernel. -/
theorem caratheodory_positive_definite (Func : â„‚ â†’ â„‚) (hC : IsCaratheodory Func) :
    âˆ€ (n : â„•) (z : Fin n â†’ â„‚) (hz : âˆ€ i, Complex.abs (z i) < 1) (c : Fin n â†’ â„‚),
      0 â‰¤ (âˆ‘ i : Fin n, âˆ‘ j : Fin n,
        c i * starRingEnd â„‚ (c j) * caratheodoryKernel Func (z i) (z j)).re := by
  sorry -- Classical 1911 result

end ExplicitFormula
end RiemannRecognitionGeometry

================================================================================
END OF BUNDLE (updated with HilbertRealization.lean)
================================================================================
